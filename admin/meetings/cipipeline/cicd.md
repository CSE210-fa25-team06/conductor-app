# Continuous Integration / Continuous Deployment

## 1. ESLint
ESLint is used to lint JavaScript, both in the frontend and the backend. It will enforce consistent style & catch potential errors before they cause issues. The standards that are enforced can be changed in “eslint.config.mjs”, or on a per-file basis using [configuration comments](https://eslint.org/docs/latest/use/configure/rules). More information on ESLint setup can be found [here](https://eslint.org/docs/latest/use/configure/configuration-files). Currently, ESLint runs on every push and every pull request to ensure only consistent JavaScript is merged into main.

## 2. CSS Linter
Stylelint is a linter used to enforce consistent code style and detect errors in our CSS files. By automatically checking for stylistic issues and potential problems, it helps maintain a clean and readable codebase. The linter is configured through the .stylelintrc.json file, which extends the stylelint-config-standar (a set of rules based on common stylistic conventions). This base configuration can be customized by adding or overriding specific rules in the future to fit the team's evolving needs. Stylelint is integrated into the CI/CD pipeline, running on every push and pull request to ensure that all committed code follows the established standards.

## 3. HTML Linter
HTMLHint is used to lint all of the HTML in the project. It, like other linters, enforces good and common practices within HTML. It is configured through the .htmlhintrc configuration file at the root of the project. HTMLHint has a variety of rules, accessible [here](https://htmlhint.com/rules/), which can be easily enabled or disabled in the config file. Note that HTMLHint only lints html, and does not run it. As such, it can enforce best practices but not necessarily ensure the page is functional. HTMLHint runs on all HTML files on every push and pull request.

## 4. Pa11y
Pa11y is an webpage accessibility tester. We are using, specifically, [Pa11y-CI](https://github.com/pa11y/pa11y-ci), as it is command line accessible and thus works well as part of a CI/CD pipeline. It is configured through the .pa11yci file. At its core, Pa11y just tests a list of URLs which are provided to it through the aforementioned config file. However, it can be configured to more thoroughly test pages using various methods, like performing actions, which are better documented on the [standard Pa11y repo](https://github.com/pa11y/pa11y?tab=readme-ov-file#actions). Pa11y enforces the [Web Content Accessibility Guidelines 2.1](https://www.w3.org/TR/WCAG21/), and you are able to set testing between A and AAA compliance. Currently, Pa11y is set to enforce AA compliance. Because Pa11y is significantly more involved than a standard linter, it is important to maintain its config file to ensure it’s testing all relevant portions of the application. Pa11y currently runs on every push and pull request.

## 5. Testing
The Jest framework is used to write our integration tests and client-side unit tests. It provides a great interface to interact with a webpage or application in a way that is almost human-like. One example of how you may think of this is a user clicking on a button. A bad testing library would automatically find the button and click on it, but Jest under the hood will actually simulate moving the cursor to that button and clicking it. Jest also provides the means to look into code coverage, both at the statement level and branch level. Code coverage is not the end all be all but it provides insight into dead code that can be refactored. Jest also simplifies mock definitions and their initialization in testing suites. It also integrates well into the pipeline with a simple npm command to run all tests.

## 6. Docker
Docker is used to containerize our application and database, providing a consistent and reproducible environment for both development and testing. By packaging the Node.js server and PostgreSQL database into isolated containers, it eliminates environment-specific issues and simplifies the project setup process. The containerization is configured through two files in the project directory: the Dockerfile, which specifies the steps to build the application image (node server), and docker-compose.yml, which defines and connects the application and PostgreSQL service. Docker compose setup is also configured to automatically set up the database by running schema.sql and seed.sql files on its first launch. As a core component of our CI/CD pipeline, Docker Compose is used on every push and pull request to build the entire stack and run our test suite, ensuring all code is validated in a clean, production-like environment before it is merged.

## 7. Human Review
Human review happens through pull requests and is a required part of our workflow. We use branch protection rules that require at least two approvals before anything can be merged into main. The linters and accessibility tests should pass before approval but in rare cases when a deadline is tight or a critical feature needs to go in we will allow the merge even if a few tests fail. This choice will only be made with clear communication and agreement from reviewers.

During review, we check for more than correctness. We look at whether the code is written in a clear way and whether the file structure and file names follow the project guidelines. We also check that any new feature is documented in the correct place so future developers understand what it does. Reviewers also point out design concerns and catch small details that automated tools cannot see.

## Diagram
![CI/CD Diagram](cicd.JPG "CI/CD Diagram")
